'''
Apply k-means to cluster digit-recognizer dataset.

Because we actually have the true ground set, we can evaluate the quality of k-means using purity.
'''
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA


def read_csv(limit=1000, path='../data/digit-recognizer/train.csv'):
    data = pd.read_csv(path)
    data = data.to_numpy()
    X = data[:, 1:]
    y = data[:, 0]

    X = X[:limit]
    y = y[:limit]
    return X, y


class K_mean:

    def __init__(self, K):
        '''

        :param K: number of clusters
        '''
        self.K = K

    def fit(self, X, y):
        # use dimensionality reduction to reduce the cost of computation
        pca = PCA(n_components=10)
        X_embedded = pca.fit_transform(X)

        # clustering
        kmeans = KMeans(n_clusters=self.K, random_state=0).fit(X_embedded)
        cluster = kmeans.labels_

        # evaluate the clustering
        self.purity = self.compute_purity(y, cluster)

    def compute_intersection(self, list1, list2):
        count = 0

        for item in list1:
            if item in list2:
                count += 1

        return count

    def compute_purity(self, y, cluster):
        '''
        Use to evaluate the clustering. The higher value of purity, the better the performance of k-means.
        :param y: the true labels
        :param cluster:the clusters generated by k-means
        :return: between 0 and 1
        '''
        N = len(y)
        purity = 0

        for k in range(self.K):
            c = [i for i in range(len(cluster)) if cluster[i] == k]
            intersections = []

            for j in range(self.K):
                t = [i for i in range(len(y)) if y[i] == j]
                intersection = self.compute_intersection(c, t)
                intersections.append(intersection)

            purity += np.max(intersections)

        purity /= N
        return purity


if __name__ == '__main__':
    X, y = read_csv()
    clustering = K_mean(K=10) # there are 10 classes (i.e., 0..9), just choose the number of clusters = 10
    clustering.fit(X, y)
    print('Use purity for evaluation the clustering result.')
    print('Purity [0..1] = ' + str(clustering.purity))